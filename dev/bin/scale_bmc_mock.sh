#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="/tmp"
REPO_ROOT="$(pwd)"

COUNT=500
START_PORT=20000
HOST="127.0.0.1"
CONFIG_OUT="${SCRIPT_DIR}/config.bmc-mock.scale-500.toml"
PID_FILE="${SCRIPT_DIR}/.bmc-mock-scale.pids"
LOG_DIR="${SCRIPT_DIR}/.bmc-mock-scale-logs"
BUILD=true

usage() {
    cat <<EOF
Usage:
  $(basename "$0") up [options]
  $(basename "$0") down [options]
  $(basename "$0") config [options]
  $(basename "$0") status [options]

Commands:
  up       Build and start bmc-mock instances, then generate health config.
  down     Stop bmc-mock instances listed in the pid file.
  config   Generate health config only.
  status   Print current process status from pid file.

Options:
  --count N          Number of bmc-mock instances and config entries (default: ${COUNT})
  --start-port P     First port to use; ports are P..P+N-1 (default: ${START_PORT})
  --host IP          Host/IP for static endpoints (default: ${HOST})
  --config-out PATH  Output config path (default: ${CONFIG_OUT})
  --pid-file PATH    PID file path for started instances (default: ${PID_FILE})
  --log-dir PATH     Directory for bmc-mock logs (default: ${LOG_DIR})
  --no-build         Skip cargo build and use existing target/debug/bmc-mock binary
  -h, --help         Show this help

Examples:
  $(basename "$0") up
  $(basename "$0") up --count 100 --start-port 25000
  $(basename "$0") down
  $(basename "$0") config --count 500 --config-out crates/health/example/config.scale.toml
EOF
}

die() {
    echo "error: $*" >&2
    exit 1
}

validate_positive_int() {
    local name="$1"
    local value="$2"
    [[ "${value}" =~ ^[0-9]+$ ]] || die "${name} must be a non-negative integer, got '${value}'"
}

mac_from_index() {
    local index="$1"
    local b3 b4 b5
    b3=$(( (index >> 16) & 255 ))
    b4=$(( (index >> 8) & 255 ))
    b5=$(( index & 255 ))
    printf "02:00:00:%02x:%02x:%02x" "${b3}" "${b4}" "${b5}"
}

generate_config() {
    mkdir -p "$(dirname "${CONFIG_OUT}")"
    {
        cat <<EOF
# Generated by $(basename "$0")
# Entries: ${COUNT}
# Ports: ${START_PORT}..$((START_PORT + COUNT - 1))
#
# Run health with:
#   cargo run -p carbide-health --bin forge-hw-health -- ${CONFIG_OUT}

shard = 0
shards_count = 1
cache_size = 100

[endpoint_sources.carbide_api]
enabled = false

[sinks.tracing]
enabled = true

[sinks.prometheus]
enabled = true

[sinks.health_override]
enabled = false

EOF
        for ((i = 0; i < COUNT; i++)); do
            local_port=$((START_PORT + i))
            local_mac="$(mac_from_index "$((i + 1))")"
            cat <<EOF
[[endpoint_sources.static_bmc_endpoints]]
ip = "${HOST}"
port = ${local_port}
mac = "${local_mac}"
username = "admin"
password = "secret"

EOF
        done
    } > "${CONFIG_OUT}"

    echo "Generated config: ${CONFIG_OUT} (${COUNT} static endpoints)"
}

running_count_from_pid_file() {
    local running=0
    [[ -f "${PID_FILE}" ]] || {
        echo 0
        return
    }
    while read -r pid _; do
        [[ -n "${pid}" ]] || continue
        if kill -0 "${pid}" 2>/dev/null; then
            running=$((running + 1))
        fi
    done < "${PID_FILE}"
    echo "${running}"
}

build_binary_if_needed() {
    if [[ "${BUILD}" == "true" ]]; then
        echo "Building bmc-mock binary..."
        (cd "${REPO_ROOT}" && cargo build -p bmc-mock)
    fi
}

start_mocks() {
    local running
    running="$(running_count_from_pid_file)"
    if [[ "${running}" -gt 0 ]]; then
        die "found ${running} running mocks in ${PID_FILE}; run '$(basename "$0") down' first"
    fi

    build_binary_if_needed
    local bin="${REPO_ROOT}/target/debug/bmc-mock"
    [[ -x "${bin}" ]] || die "bmc-mock binary not found at ${bin}"

    mkdir -p "${LOG_DIR}"
    : > "${PID_FILE}"

    echo "Starting ${COUNT} bmc-mock instances on ports ${START_PORT}..$((START_PORT + COUNT - 1))..."
    for ((i = 0; i < COUNT; i++)); do
        local_port=$((START_PORT + i))
        local_mac="$(mac_from_index "$((i + 1))")"
        "${bin}" --port "${local_port}" > "${LOG_DIR}/bmc-mock-${local_port}.log" 2>&1 &
        pid=$!
        printf "%s %s %s\n" "${pid}" "${local_port}" "${local_mac}" >> "${PID_FILE}"
    done

    echo "Started ${COUNT} instances."
    echo "PID file: ${PID_FILE}"
    echo "Logs dir: ${LOG_DIR}"
}

stop_mocks() {
    [[ -f "${PID_FILE}" ]] || {
        echo "PID file not found: ${PID_FILE}"
        return
    }

    local total=0
    local stopped=0
    while read -r pid _; do
        [[ -n "${pid}" ]] || continue
        total=$((total + 1))
        if kill -0 "${pid}" 2>/dev/null; then
            kill "${pid}" 2>/dev/null || true
            stopped=$((stopped + 1))
        fi
    done < "${PID_FILE}"

    sleep 1
    while read -r pid _; do
        [[ -n "${pid}" ]] || continue
        if kill -0 "${pid}" 2>/dev/null; then
            kill -9 "${pid}" 2>/dev/null || true
        fi
    done < "${PID_FILE}"

    rm -f "${PID_FILE}"
    echo "Stopped ${stopped}/${total} instances and removed ${PID_FILE}"
}

status_mocks() {
    if [[ ! -f "${PID_FILE}" ]]; then
        echo "No pid file: ${PID_FILE}"
        return
    fi
    local total
    total="$(wc -l < "${PID_FILE}" | tr -d ' ')"
    local running
    running="$(running_count_from_pid_file)"
    echo "PID file: ${PID_FILE}"
    echo "Tracked: ${total}"
    echo "Running: ${running}"
}

COMMAND="${1:-help}"
if [[ $# -gt 0 ]]; then
    shift
fi

while [[ $# -gt 0 ]]; do
    case "$1" in
        --count)
            COUNT="${2:-}"
            shift 2
            ;;
        --start-port)
            START_PORT="${2:-}"
            shift 2
            ;;
        --host)
            HOST="${2:-}"
            shift 2
            ;;
        --config-out)
            CONFIG_OUT="${2:-}"
            shift 2
            ;;
        --pid-file)
            PID_FILE="${2:-}"
            shift 2
            ;;
        --log-dir)
            LOG_DIR="${2:-}"
            shift 2
            ;;
        --no-build)
            BUILD=false
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            die "unknown argument: $1"
            ;;
    esac
done

validate_positive_int "count" "${COUNT}"
validate_positive_int "start-port" "${START_PORT}"

if [[ "${COUNT}" -eq 0 ]]; then
    die "count must be greater than 0"
fi

case "${COMMAND}" in
    up)
        start_mocks
        generate_config
        ;;
    down)
        stop_mocks
        ;;
    config)
        generate_config
        ;;
    status)
        status_mocks
        ;;
    help|-h|--help)
        usage
        ;;
    *)
        die "unknown command: ${COMMAND}"
        ;;
esac
