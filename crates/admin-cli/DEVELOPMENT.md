# Admin CLI Development Guide

This guide covers how to develop new subcommands, and work on existing
subcommands, in the `admin-cli` crate (for `carbide-admin-cli`).

## Table of Contents

- [Module Structure](#module-structure)
- [The Dispatch and Run Traits](#the-dispatch-and-run-traits)
- [The Dispatch Derive Macro](#the-dispatch-derive-macro)
- [RuntimeContext and RuntimeConfig](#runtimecontext-and-runtimeconfig)
- [Creating a New Subcommand](#creating-a-new-subcommand)
- [Nested Command Groups](#nested-command-groups)
- [Testing](#testing)

## Module Structure

Each command group lives in its own module directory under `src/`. Within
that directory, each leaf command (show, list, delete, etc.) gets its own
subdirectory with a consistent three-file structure:

```
src/
└── my_command/
    ├── mod.rs          # Cmd enum with #[derive(Dispatch)].
    ├── tests.rs        # Unit tests for arg parsing.
    ├── show/
    │   ├── mod.rs      # Run implementation for show.
    │   ├── args.rs     # Clap argument definitions.
    │   └── cmd.rs      # Command handler implementation.
    ├── list/
    │   ├── mod.rs      # Run implementation for list.
    │   ├── args.rs     # Clap argument definitions.
    │   └── cmd.rs      # Command handler implementation.
    └── delete/
        ├── mod.rs      # Run implementation for delete.
        ├── args.rs     # Clap argument definitions.
        └── cmd.rs      # Command handler implementation.
```

### Command Group mod.rs

The command group's `mod.rs` declares its leaf command submodules, exports
the `Cmd` enum, and derives `Dispatch`. This is all that's needed -- the
derive macro auto-generates the dispatch routing.

```rust
mod delete;
mod list;
mod show;

#[cfg(test)]
mod tests;

use clap::Parser;

use crate::cfg::dispatch::Dispatch;

#[derive(Parser, Debug, Dispatch)]
pub enum Cmd {
    #[clap(about = "Show items")]
    Show(show::Args),
    #[clap(about = "List all items")]
    List(list::Args),
    #[clap(about = "Delete an item")]
    Delete(delete::Args),
}
```

### Leaf Command mod.rs

Each leaf command's `mod.rs` implements the `Run` trait on its `Args`
type. This is the bridge between argument parsing and execution --
it pulls what it needs from `RuntimeContext` and delegates to the
handler in `cmd.rs`.

```rust
pub mod args;
pub mod cmd;

use ::rpc::admin_cli::CarbideCliResult;
pub use args::Args;

use crate::cfg::run::Run;
use crate::cfg::runtime::RuntimeContext;

impl Run for Args {
    async fn run(self, ctx: &mut RuntimeContext) -> CarbideCliResult<()> {
        cmd::show(&ctx.api_client, self, ctx.config.format).await
    }
}
```

### Leaf Command args.rs

Contains the clap argument definitions for a single leaf command:

```rust
use clap::Parser;

#[derive(Parser, Debug)]
pub struct Args {
    #[clap(help = "Optional item ID")]
    pub id: Option<String>,

    #[clap(short, long, help = "Filter by name")]
    pub name: Option<String>,
}
```

### Leaf Command cmd.rs

Contains the actual command handler. Receives parsed arguments and
only the specific dependencies it needs (not the full RuntimeContext):

```rust
use ::rpc::admin_cli::{CarbideCliResult, OutputFormat};

use super::args::Args;
use crate::rpc::ApiClient;

pub async fn show(
    api_client: &ApiClient,
    args: Args,
    format: OutputFormat,
) -> CarbideCliResult<()> {
    // Implementation here.
    Ok(())
}
```

## The Dispatch and Run Traits

Command execution flows through two traits that separate routing from
execution.

### Dispatch

The `Dispatch` trait (defined in `src/cfg/dispatch.rs`) is implemented
on command group `Cmd` enums. It routes a parsed command to the correct
leaf handler. You should never need to implement this by hand -- use
`#[derive(Dispatch)]` instead (see below).

```rust
pub(crate) trait Dispatch {
    fn dispatch(
        self,
        ctx: RuntimeContext,
    ) -> impl std::future::Future<Output = CarbideCliResult<()>>;
}
```

### Run

The `Run` trait (defined in `src/cfg/run.rs`) is implemented on leaf
command `Args` structs. It executes a single command, pulling what it
needs from the `RuntimeContext`.

```rust
pub(crate) trait Run {
    fn run(
        self,
        ctx: &mut RuntimeContext,
    ) -> impl std::future::Future<Output = CarbideCliResult<()>>;
}
```

### Key Differences

| | Dispatch | Run |
|---|---|---|
| **Implemented on** | `Cmd` enums (command groups) | `Args` structs (leaf commands) |
| **Context** | Takes `ctx` by value (ownership) | Takes `&mut ctx` (mutable borrow) |
| **Generated by** | `#[derive(Dispatch)]` | Hand-written |
| **Purpose** | Routes to the correct leaf command | Executes a single command |

## The Dispatch Derive Macro

The `#[derive(Dispatch)]` macro (defined in `crates/macros`) generates
a `Dispatch` impl automatically. It iterates the enum's variants and
calls `.run(&mut ctx)` on each variant's inner type.

```rust
use crate::cfg::dispatch::Dispatch;

#[derive(Parser, Debug, Dispatch)]
pub enum Cmd {
    Show(show::Args),    // show::Args implements Run
    List(list::Args),    // list::Args implements Run
    Delete(delete::Args) // delete::Args implements Run
}
```

The import `use crate::cfg::dispatch::Dispatch` brings both the trait
and the derive macro into scope (they share the name, like clap's
`Parser`).

For nested command groups where a variant holds another `Cmd` enum
that implements `Dispatch` (rather than a leaf `Args` that implements
`Run`), annotate the variant with `#[dispatch]`:

```rust
#[derive(Parser, Debug, Dispatch)]
pub enum Cmd {
    Show(show::Args),       // Leaf command -- calls .run()
    #[dispatch]
    SubGroup(sub::Cmd),     // Nested group -- calls .dispatch()
}
```

## RuntimeContext and RuntimeConfig

The `RuntimeContext` (defined in `src/cfg/runtime.rs`) bundles all runtime
dependencies passed to dispatch handlers:

```rust
pub struct RuntimeContext {
    pub api_client: ApiClient,
    pub config: RuntimeConfig,
    pub output_file: Pin<Box<dyn tokio::io::AsyncWrite>>,
}

pub struct RuntimeConfig {
    pub format: OutputFormat,           // Output format (Table, JSON, CSV)
    pub page_size: usize,              // Pagination size for list operations
    pub extended: bool,                // Show extended/detailed output
    pub cloud_unsafe_op_enabled: bool, // Allow unsafe cloud operations
    pub sort_by: SortField,            // Sort field for list operations
}
```

### Using RuntimeContext in Run Implementations

Extract only what your handler needs in the `Run` impl, and pass
those specific values to `cmd.rs`:

```rust
impl Run for Args {
    async fn run(self, ctx: &mut RuntimeContext) -> CarbideCliResult<()> {
        // Simple handler -- just needs API client.
        cmd::show(&ctx.api_client, self).await

        // Paginated list additionally needs page_size.
        cmd::list(&ctx.api_client, self, ctx.config.page_size).await

        // Extended output additionally needs the extended flag.
        cmd::show(&ctx.api_client, self, ctx.config.format, ctx.config.extended).await

        // Writing to file.
        cmd::export(&mut ctx.output_file, &ctx.api_client, self).await
    }
}
```

## Creating a New Subcommand

### Step 1: Create the Directory Structure

```bash
mkdir -p src/my_command/show
```

### Step 2: Create the Leaf Command

Create `src/my_command/show/args.rs`:

```rust
/*
 * SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION & AFFILIATES.
 * SPDX-License-Identifier: Apache-2.0
 * ..etc etc.
 */

use clap::Parser;

#[derive(Parser, Debug)]
pub struct Args {
    #[clap(help = "Optional item ID")]
    pub id: Option<String>,
}
```

Create `src/my_command/show/cmd.rs`:

```rust
/*
 * SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION & AFFILIATES.
 * SPDX-License-Identifier: Apache-2.0
 * ..etc etc.
 */

use ::rpc::admin_cli::CarbideCliResult;

use super::args::Args;
use crate::rpc::ApiClient;

pub async fn show(api_client: &ApiClient, args: Args) -> CarbideCliResult<()> {
    // Your implementation here.
    Ok(())
}
```

Create `src/my_command/show/mod.rs`:

```rust
/*
 * SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION & AFFILIATES.
 * SPDX-License-Identifier: Apache-2.0
 * ..etc etc.
 */

pub mod args;
pub mod cmd;

use ::rpc::admin_cli::CarbideCliResult;
pub use args::Args;

use crate::cfg::run::Run;
use crate::cfg::runtime::RuntimeContext;

impl Run for Args {
    async fn run(self, ctx: &mut RuntimeContext) -> CarbideCliResult<()> {
        cmd::show(&ctx.api_client, self).await
    }
}
```

### Step 3: Create the Command Group

Create `src/my_command/mod.rs`:

```rust
/*
 * SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION & AFFILIATES.
 * SPDX-License-Identifier: Apache-2.0
 * ..etc etc.
 */

mod show;

#[cfg(test)]
mod tests;

use clap::Parser;

use crate::cfg::dispatch::Dispatch;

#[derive(Parser, Debug, Dispatch)]
pub enum Cmd {
    #[clap(about = "Show items")]
    Show(show::Args),
}
```

### Step 4: Create tests.rs

Add unit tests (see [Testing](#testing) section below).

### Step 5: Register the Subcommand

Add to `src/main.rs`:

```rust
mod my_command;
```

Add to `CliCommand` enum in `src/cfg/cli_options.rs`:

```rust
pub enum CliCommand {
    // ... existing commands ...
    #[clap(about = "My subcommand description", subcommand)]
    MyCommand(my_command::Cmd),
}
```

Add dispatch routing in `src/main.rs`:

```rust
match command {
    // ... existing commands ...
    CliCommand::MyCommand(cmd) => cmd.dispatch(ctx).await?,
}
```

## Nested Command Groups

Sometimes a command group contains other command groups rather than
(or in addition to) leaf commands. For example, a `machine` command
might have both leaf commands (`show`, `reboot`) and a nested group
(`network` with its own subcommands).

Use the `#[dispatch]` attribute on variants that hold a nested `Cmd`
enum:

```rust
#[derive(Parser, Debug, Dispatch)]
pub enum Cmd {
    #[clap(about = "Show machine info")]
    Show(show::Args),                        // Leaf -- implements Run.
    #[clap(about = "Reboot a machine")]
    Reboot(reboot::Args),                    // Leaf -- implements Run.
    #[clap(subcommand, about = "Networking")]
    #[dispatch]
    Network(network::Cmd),                   // Nested group -- implements Dispatch.
}
```

The nested group (`network`) follows the same structure -- its own
`mod.rs` with `#[derive(Dispatch)]`, its own leaf commands, and
potentially its own nested groups.

## Testing

Each command group should have a `tests.rs` file that validates command
structure and argument parsing. Tests are organized into categories.
Note the repetitive/boilerplate comments. While not needed, it helps those
who happen to look at your specific `tests.rs`.

### Test File Structure

```rust
/*
 * SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION & AFFILIATES.
 * SPDX-License-Identifier: Apache-2.0
 * ..etc etc.
 */

// The intent of the tests.rs file is to test the integrity of the
// command, including things like basic structure parsing, enum
// translations, and any external input validators that are
// configured. Specific "categories" are:
//
// Command Structure - Baseline debug_assert() of the entire command.
// Argument Parsing  - Ensure required/optional arg combinations parse correctly.
// ValueEnum Parsing - Test clap ValueEnum translations (if applicable).
// Validation Logic  - Test business logic validators (if applicable).

use clap::{CommandFactory, Parser};

use super::*;
```

### Boilerplate Tests (Required!)

Every subcommand MUST have a basic command structure test:

```rust
// verify_cmd_structure runs a baseline clap debug_assert()
// to do basic command configuration checking and validation,
// ensuring things like unique argument definitions, group
// configurations, argument references, etc. Things that would
// otherwise be missed until runtime.
#[test]
fn verify_cmd_structure() {
    Cmd::command().debug_assert();
}
```

From there, you should also have a test that it parses with
no arguments (or minimal arguments).

```rust
// parse_show_no_args ensures show parses with no
// arguments (all items).
#[test]
fn parse_show_no_args() {
    let cmd = Cmd::try_parse_from(["my-cmd", "show"])
        .expect("should parse show");

    match cmd {
        Cmd::Show(args) => {
            assert!(args.id.is_none());
        }
        _ => panic!("expected Show variant"),
    }
}
```

### Conditional Tests (Optional, based on command features)

You should add these additional types of tests based on what
your command supports.

#### Commands with Required Arguments

For required arguments, you should test that these parse as expected,
with the added benefit of it being a nice, self-documenting way for
people to see how to interact with your command.

```rust
// parse_create_missing_required_fails ensures create
// fails without required arguments.
#[test]
fn parse_create_missing_required_fails() {
    let result = Cmd::try_parse_from(["my-cmd", "create"]);
    assert!(result.is_err(), "should fail without --name");
}
```

#### Commands with Optional Filters

Similar to required arguments, test that various --flag arguments
parse as expected, again being a self-documenting way to show
how to interact (and not interact) with your command.

```rust
// parse_show_with_name ensures show parses with --name.
#[test]
fn parse_show_with_name() {
    let cmd = Cmd::try_parse_from(["my-cmd", "show", "--name", "test"])
        .expect("should parse show with name");

    match cmd {
        Cmd::Show(args) => {
            assert_eq!(args.name, Some("test".to_string()));
        }
        _ => panic!("expected Show variant"),
    }
}
```

#### Commands with ValueEnum Arguments

When testing enums that don't derive `PartialEq`, use `matches!`:

```rust
// parse_create_with_type ensures create parses with
// --type argument.
#[test]
fn parse_create_with_type() {
    let cmd = Cmd::try_parse_from([
        "my-cmd", "create", "--type", "dpu"
    ]).expect("should parse create with type");

    match cmd {
        Cmd::Create(args) => {
            assert!(matches!(args.item_type, ItemType::Dpu));
        }
        _ => panic!("expected Create variant"),
    }
}

// parse_create_invalid_type_fails ensures create fails
// with invalid type value.
#[test]
fn parse_create_invalid_type_fails() {
    let result = Cmd::try_parse_from([
        "my-cmd", "create", "--type", "invalid"
    ]);
    assert!(result.is_err(), "should fail with invalid type");
}
```

#### Commands with Argument Groups

Test mutually exclusive or required-together arguments:

```rust
// parse_show_conflict_fails ensures show fails with
// conflicting arguments.
#[test]
fn parse_show_conflict_fails() {
    let result = Cmd::try_parse_from([
        "my-cmd", "show", "--id", "123", "--all"
    ]);
    assert!(result.is_err(), "should fail with both --id and --all");
}

// parse_update_requires_both ensures update requires
// both username and password together.
#[test]
fn parse_update_requires_both() {
    let result = Cmd::try_parse_from([
        "my-cmd", "update", "--username", "admin"
    ]);
    assert!(result.is_err(), "should fail with username but no password");
}
```

#### Commands with Custom Validators

Test business logic validation methods:

```rust
// validate_no_duplicates ensures validate() passes
// with unique values.
#[test]
fn validate_no_duplicates() {
    let cmd = Cmd::try_parse_from([
        "my-cmd", "create", "--item", "a", "--item", "b"
    ]).expect("should parse");

    match cmd {
        Cmd::Create(args) => {
            assert!(args.validate().is_ok(), "unique items should validate");
        }
        _ => panic!("expected Create variant"),
    }
}

// validate_duplicates_fail ensures validate() fails
// with duplicate values.
#[test]
fn validate_duplicates_fail() {
    let cmd = Cmd::try_parse_from([
        "my-cmd", "create", "--item", "a", "--item", "a"
    ]).expect("should parse");

    match cmd {
        Cmd::Create(args) => {
            assert!(args.validate().is_err(), "duplicates should fail");
        }
        _ => panic!("expected Create variant"),
    }
}
```

### Test ID Constants

For commands that take IDs, define constants at the top of the test file:

```rust
// Standard UUID format for VpcId, InstanceId, etc.
const TEST_VPC_ID: &str = "00000000-0000-0000-0000-000000000001";

// Known format for MachineId.
const TEST_MACHINE_ID: &str =
    "fm100ht038bg3qsho433vkg684heguv282qaggmrsh2ugn1qk096n2c6hcg";
```

### Comment Style

Test function comments should include the name of the test,
as well as what the test is testing.

```rust
// parse_show_with_filters ensures show parses with
// multiple filter arguments.
#[test]
fn parse_show_with_filters() {
    // ...
}
```

### Running Tests

Nothing exciting here, but worth mentioning for completeness!

```bash
# Run all tests
cargo test

# Run tests for a specific subcommand
cargo test my_subcommand::tests

# Run a specific test
cargo test my_subcommand::tests::verify_cmd_structure
```
